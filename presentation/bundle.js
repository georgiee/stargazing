!function(e){var n={};function t(r){if(n[r])return n[r].exports;var s=n[r]={i:r,l:!1,exports:{}};return e[r].call(s.exports,s,s.exports,t),s.l=!0,s.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var s in e)t.d(r,s,function(n){return e[n]}.bind(null,s));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="/stargazing/",t(t.s="./src/presentation/main.ts")}({"./src/presentation/main.ts":
/*!**********************************!*\
  !*** ./src/presentation/main.ts ***!
  \**********************************/
/*! no exports provided */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _virtual_fragments__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./virtual-fragments */ "./src/presentation/virtual-fragments.ts");\n/* harmony import */ var _support_complete_constellation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./support/complete-constellation */ "./src/presentation/support/complete-constellation.ts");\n/* harmony import */ var _support_thank_you__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./support/thank-you */ "./src/presentation/support/thank-you.ts");\n/* harmony import */ var _support_line_fragments__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./support/line-fragments */ "./src/presentation/support/line-fragments.ts");\n\n\n\n\ndocument.addEventListener(\'DOMContentLoaded\', run);\nfunction setpVirtualIframes() {\n    const iframes = document.querySelectorAll(\'[data-virtual-iframe]\');\n    const elements = Array.from(iframes);\n    elements.forEach(iframe => {\n        Object(_virtual_fragments__WEBPACK_IMPORTED_MODULE_0__["virtualIframeFragments"])(iframe);\n    });\n}\nfunction run() {\n    setpVirtualIframes();\n    Object(_support_line_fragments__WEBPACK_IMPORTED_MODULE_3__["lineFragments"])();\n    Object(_support_complete_constellation__WEBPACK_IMPORTED_MODULE_1__["completeConstellation"])();\n    Object(_support_thank_you__WEBPACK_IMPORTED_MODULE_2__["thankYou"])();\n}\n\n\n//# sourceURL=webpack:///./src/presentation/main.ts?')},"./src/presentation/prism-highlighter.ts":
/*!***********************************************!*\
  !*** ./src/presentation/prism-highlighter.ts ***!
  \***********************************************/
/*! exports provided: PRISM_LINE_HIGHLIGHTER_MODE_BUILD, PRISM_LINE_HIGHLIGHTER_MODE_ABSOLUTE, PrismLineHighlighter */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PRISM_LINE_HIGHLIGHTER_MODE_BUILD", function() { return PRISM_LINE_HIGHLIGHTER_MODE_BUILD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PRISM_LINE_HIGHLIGHTER_MODE_ABSOLUTE", function() { return PRISM_LINE_HIGHLIGHTER_MODE_ABSOLUTE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PrismLineHighlighter", function() { return PrismLineHighlighter; });\n/**\n * This class helps you to highlight prismjs block step by step.\n * 1. The steps are created with SlideBuilder (which creates virtual fragments)\n * 2. This class reads [data-line-fragments] for a list of lines to highlight\n * ```\n * Example:\n * <pre data-line-fragments=\'["5", "7", "9-11", "9-13, 1, 2, 3"]\'>\n *   ///\n * ```\n *\n * Important: It\'s being parsed as json so use an array and double quotes\n *\n * 3. In normal mode (BUILD) the lines will be accumulated, the fina result: show all lines\n * 4. You can enable absolute mode (ABSOLUTE) which will show each entry individually.\n * e.g. first "5", then "7", then "9-11", then lines "9-13, 1, 2, 3". This gives you full control over\n * the displayed highlighted code.\n */\nconst PRISM_LINE_HIGHLIGHTER_MODE_BUILD = 1;\nconst PRISM_LINE_HIGHLIGHTER_MODE_ABSOLUTE = 2;\nclass PrismLineHighlighter {\n    constructor(_prismElement, showFirst = false) {\n        this._prismElement = _prismElement;\n        this._steps = [];\n        this._cursor = 0;\n        this._mode = PRISM_LINE_HIGHLIGHTER_MODE_BUILD;\n        this._showFirst = true;\n        this._showFirst = showFirst;\n        const stepsDataInput = this._prismElement.dataset.lineFragments;\n        const mode = this._prismElement.dataset.lineFragmentsMode;\n        // is a fragment index applied to the pre?\n        const fragmentIndex = parseInt(this._prismElement.dataset.fragmentIndex) || 0;\n        console.log(\'fragmentIndex\', fragmentIndex);\n        // we need to let the virtual fragments appear after the block itself apperas\n        const ownFragmentIndex = fragmentIndex + 1;\n        if (mode) {\n            if (mode === \'absolute\') {\n                this.setMode(PRISM_LINE_HIGHLIGHTER_MODE_ABSOLUTE);\n            }\n            else if (mode === \'build\') {\n                this.setMode(PRISM_LINE_HIGHLIGHTER_MODE_BUILD);\n            }\n        }\n        this._steps = JSON.parse(stepsDataInput);\n        this._slideBuilder = new SlideBuilder(this.slide, ownFragmentIndex);\n        this.init();\n    }\n    // choose how to reveal your lines. defaults to PRISM_LINE_HIGHLIGHTER_MODE_BUILD\n    setMode(value) {\n        this._mode = value;\n    }\n    init() {\n        const fragmentList = createFragments({\n            repeat: this.totalStepCount,\n            callback: () => this.next()\n        });\n        this._slideBuilder\n            .shown(({ direction }) => this.prepare(direction))\n            .fragments(fragmentList, () => this.previous());\n    }\n    getCurrentStepValue() {\n        let stepList = [];\n        if (this._mode === PRISM_LINE_HIGHLIGHTER_MODE_BUILD) {\n            // just extract the window marked with 0 -> cursor\n            const steps = [null, ...this._steps];\n            stepList = steps.slice(0, this._cursor + 1);\n        }\n        else if (this._mode === PRISM_LINE_HIGHLIGHTER_MODE_ABSOLUTE) {\n            // in absolute build mode we only want to use the given\n            // lines at the specified cursor position\n            // ensure that the first step is empty so we can start with no highlight\n            const prefix = this._showFirst ? [] : [null];\n            const steps = [...prefix, ...this._steps];\n            const item = steps[this._cursor];\n            stepList = [item];\n        }\n        // get all lines, remove null values (our sentinel for no highlight)\n        let currentLines = stepList.filter(value => !!value).join(\',\');\n        // make sure that an empty array get represetend as an space otheriwse\n        // prism won\'t remove our highlight\n        if (currentLines.length === 0) {\n            currentLines = " ";\n        }\n        return currentLines;\n    }\n    update() {\n        this._prismElement.dataset.line = this.getCurrentStepValue();\n        Prism.highlightAllUnder(this.slide);\n    }\n    prepare(direction) {\n        if (direction >= 0) {\n            this._cursor = 0;\n        }\n        else {\n            this._cursor = this.totalStepCount;\n        }\n        Reveal.syncFragments(this._prismElement.closest(\'section\'));\n        this.update();\n    }\n    next() {\n        this._cursor++;\n        this.update();\n    }\n    previous() {\n        this._cursor--;\n        this.update();\n    }\n    get totalStepCount() {\n        return this._steps.length;\n    }\n    get slide() {\n        return this._prismElement.closest(\'section\');\n    }\n}\nfunction createFragments({ repeat, callback }) {\n    return Array(repeat).fill(0).map(_ => callback);\n}\n\n\n//# sourceURL=webpack:///./src/presentation/prism-highlighter.ts?')},"./src/presentation/support/complete-constellation.ts":
/*!************************************************************!*\
  !*** ./src/presentation/support/complete-constellation.ts ***!
  \************************************************************/
/*! exports provided: completeConstellation, getBackgroundIframe */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"completeConstellation\", function() { return completeConstellation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getBackgroundIframe\", function() { return getBackgroundIframe; });\nfunction completeConstellation() {\n    const slideSection = document.querySelector('#constellationComplete');\n    const slideBuilder = new SlideBuilder(slideSection);\n    function play() {\n        const iframeWindow = getBackgroundIframe().contentWindow;\n        console.log('play all cosntellations');\n        iframeWindow.postMessage(\"play\", \"*\");\n    }\n    Reveal.addEventListener('ready', m => {\n        // ensure that the slide starts when directly loaded\n        if (m.currentSlide === slideSection) {\n            const iframe = getBackgroundIframe();\n            iframe.addEventListener('load', loaded);\n            //make sure iframe is loaded before sending message\n            function loaded() {\n                iframe.removeEventListener('load', loaded);\n                iframe.contentWindow.postMessage('slide:start', \"*\");\n            }\n        }\n    });\n    const fragmentList = [play];\n    slideBuilder\n        .fragments(fragmentList);\n}\n// reveals own full size background iframe\nfunction getBackgroundIframe() {\n    // many bugs in the past finding the correct one.\n    // so I query this stack with a long selector and I return ALL findings\n    const candidates = document.querySelectorAll('.backgrounds > .slide-background.present > .slide-background.present iframe');\n    console.log('bg iframe candidates', candidates);\n    const iframe = candidates[candidates.length - 1];\n    // const iframe = document.querySelector('.slide-background:not(.stack).present iframe') as HTMLIFrameElement;;\n    console.log('getBackgroundIframe', iframe);\n    return iframe;\n}\n\n\n//# sourceURL=webpack:///./src/presentation/support/complete-constellation.ts?")},"./src/presentation/support/line-fragments.ts":
/*!****************************************************!*\
  !*** ./src/presentation/support/line-fragments.ts ***!
  \****************************************************/
/*! exports provided: lineFragments */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineFragments", function() { return lineFragments; });\n/* harmony import */ var _prism_highlighter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../prism-highlighter */ "./src/presentation/prism-highlighter.ts");\n\nfunction lineFragments() {\n    const prismElements = document.querySelectorAll(\'[data-line-fragments]\');\n    const elements = Array.from(prismElements);\n    elements.forEach(element => {\n        const showFirst = element.dataset.lineFragmentsStart === \'first\';\n        const highlighter = new _prism_highlighter__WEBPACK_IMPORTED_MODULE_0__["PrismLineHighlighter"](element, showFirst);\n        // highlighter.setMode(PRISM_LINE_HIGHLIGHTER_MODE_ABSOLUTE);\n    });\n}\n\n\n//# sourceURL=webpack:///./src/presentation/support/line-fragments.ts?')},"./src/presentation/support/thank-you.ts":
/*!***********************************************!*\
  !*** ./src/presentation/support/thank-you.ts ***!
  \***********************************************/
/*! exports provided: thankYou */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"thankYou\", function() { return thankYou; });\n/* harmony import */ var _complete_constellation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complete-constellation */ \"./src/presentation/support/complete-constellation.ts\");\n\nfunction thankYou() {\n    const slideSection = document.querySelector('#thankYou');\n    Reveal.addEventListener('ready', m => {\n        // ensure that the slide starts when directly loaded\n        if (m.currentSlide === slideSection) {\n            const iframe = Object(_complete_constellation__WEBPACK_IMPORTED_MODULE_0__[\"getBackgroundIframe\"])();\n            iframe.addEventListener('load', loaded);\n            //make sure iframe is loaded before sending message\n            function loaded() {\n                iframe.removeEventListener('load', loaded);\n                iframe.contentWindow.postMessage('slide:start', \"*\");\n            }\n        }\n    });\n}\n\n\n//# sourceURL=webpack:///./src/presentation/support/thank-you.ts?")},"./src/presentation/virtual-fragments.ts":
/*!***********************************************!*\
  !*** ./src/presentation/virtual-fragments.ts ***!
  \***********************************************/
/*! exports provided: virtualIframeFragments */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "virtualIframeFragments", function() { return virtualIframeFragments; });\nconst NOOP = \'noop\';\nfunction virtualIframeFragments(iframe) {\n    const fragmentListSetup = JSON.parse(iframe.dataset.virtualIframe);\n    let fragmentList = [];\n    if (typeof fragmentListSetup === \'object\') {\n        fragmentList = createFragmentToggleList({\n            list: fragmentListSetup, callback: next\n        });\n    }\n    else {\n        fragmentList = createFragments({ repeat: fragmentListSetup, callback: next });\n    }\n    // always offset by it\'s own fragment offset + 1 so the revealing\n    // won\'t start before the iframe itself is visible\n    const fragmentIndex = 1 + (parseInt(iframe.dataset.fragmentIndex) || 0);\n    const fragmentOffset = fragmentIndex + (parseInt(iframe.dataset.virtualIframeOffset) || 0);\n    const slide = iframe.closest(\'section\');\n    function next() {\n        const contentWindow = iframe.contentWindow;\n        contentWindow.postMessage("virtual:next", "*");\n    }\n    function prev(event) {\n        const contentWindow = iframe.contentWindow;\n        contentWindow.postMessage("virtual:prev", "*");\n    }\n    function prepare(direction) {\n        const contentWindow = iframe.contentWindow;\n        let message;\n        if (direction >= 0) {\n            message = "virtual:prepare:forwards";\n        }\n        else {\n            message = "virtual:prepare:backwards";\n        }\n        //make sure iframe is loaded before sending message\n        function loaded() {\n            iframe.removeEventListener(\'load\', loaded);\n            contentWindow.postMessage(message, "*");\n        }\n        iframe.addEventListener(\'load\', loaded);\n    }\n    const slideBuilder = new SlideBuilder(slide, fragmentOffset);\n    slideBuilder\n        .shown(({ direction }) => prepare(direction))\n        .fragments(fragmentList, prev);\n}\nfunction createFragments({ repeat, callback }) {\n    return Array(repeat).fill(0).map(_ => callback);\n}\nfunction createFragmentToggleList({ list, callback }) {\n    return list.map(value => {\n        if (value > 0) {\n            return callback;\n        }\n        else {\n            return NOOP;\n        }\n    });\n}\n\n\n//# sourceURL=webpack:///./src/presentation/virtual-fragments.ts?')}});